{{define "pages/game_detail.html"}}
{{template "head" .}}
<style>
  /* Page-specific styles */
  .analysis-layout {
    display: grid;
    grid-template-columns: minmax(520px, 1fr) minmax(320px, 360px);
    gap: 1.5rem;
  }

  @media (max-width: 1080px) {
    .analysis-layout {
      grid-template-columns: 1fr;
    }
  }
</style>

<h1 class="title is-4">Game vs {{.game.Opponent}} ({{.game.TimeClass}})</h1>
<p class="mb-4">Result: {{.game.Result}} | Opening: {{.game.OpeningName}} ({{.game.ECOCode}})</p>

{{if .positions}}
<div class="analysis-layout">
  <div>
    <div class="board-container">
      <div class="player-info" id="player-top">
        <span class="piece-icon" id="icon-top"></span>
        <span class="player-name" id="name-top"></span>
        <span class="rating-badge" id="rating-top"></span>
      </div>
      <div class="board-area">
        <div class="eval-bar">
          <div class="eval-label white-advantage" id="eval-label">+0.0</div>
          <div class="eval-track">
            <div class="eval-fill" id="eval-fill"></div>
          </div>
        </div>
        <div class="board-wrapper">
          <div id="board"></div>
        </div>
      </div>
      <div class="player-info" id="player-bottom">
        <span class="piece-icon" id="icon-bottom"></span>
        <span class="player-name" id="name-bottom"></span>
        <span class="rating-badge" id="rating-bottom"></span>
      </div>
    </div>
    <div class="nav-buttons">
      <div class="buttons has-addons">
        <button class="button is-small" data-action="first" title="First move (Home)">⏮</button>
        <button class="button is-small" data-action="prev" title="Previous move (←)">⏪</button>
        <button class="button is-small" data-action="next" title="Next move (→)">⏩</button>
        <button class="button is-small" data-action="last" title="Last move (End)">⏭</button>
      </div>
      <span id="move-status" class="has-text-weight-semibold">Move 1/{{len .positions}}</span>
      <div class="auto-play-controls">
        <button class="button is-small play-button" id="auto-play-btn" title="Auto-play (Space)">
          <span id="play-icon">▶</span>
        </button>
        <input type="range" id="play-speed" class="play-speed-control" min="0.5" max="3" step="0.5" value="1" title="Playback speed">
      </div>
    </div>
    <div class="move-progress">
      <div class="move-progress-fill" id="move-progress"></div>
    </div>
    <div class="best-move-note" id="best-move-note">Best move: --</div>
  </div>

  <div>
    <div class="info-box">
      <div class="info-item">
        <strong>Opening:</strong>
        <span>{{.game.OpeningName}} ({{.game.ECOCode}})</span>
      </div>
      <div class="info-item">
        <strong>Result:</strong>
        <span>{{.game.Result}} | <strong>Played as:</strong> {{.game.PlayedAs}}</span>
      </div>
      <div class="info-item">
        <strong>Player Rating:</strong>
        <span>{{.game.PlayerRating}} | <strong>Opponent:</strong> {{.game.OpponentRating}}</span>
      </div>
      <div class="info-item">
        <strong>Date:</strong>
        <span>{{.game.PlayedAt.Format "2006-01-02"}} | <strong>Format:</strong> {{.game.TimeClass}}</span>
      </div>
      <div class="info-item">
        <strong>Flashcards:</strong>
        <span>{{.flashcard_count}}</span>
        {{if gt .flashcard_count 0}}
        <a href="/flashcards?game_id={{.game.ID}}" class="button is-small is-link ml-2">View Flashcards</a>
        {{end}}
      </div>
    </div>
    <div class="move-list-header">
      <h2 class="title is-5 mb-0">Moves</h2>
      <span class="hint">Click a move or use ← →</span>
    </div>
    <div id="move-list" class="move-list"></div>
  </div>
</div>
{{else}}
<p>Analysis pending or not available.</p>
{{end}}

{{if .positions}}
<script>
(function() {
  const positions = [
    {{- range $i, $p := .positions}}{{if $i}},{{end}}
    {
      idx: {{$i}},
      moveNumber: {{.MoveNumber}},
      fen: "{{.FEN}}",
      movePlayed: "{{.MovePlayed}}",
      bestMove: "{{.BestMove}}",
      evalBefore: {{printf "%.2f" .EvalBefore}},
      evalAfter: {{printf "%.2f" .EvalAfter}},
      evalDiff: {{printf "%.2f" .EvalDiff}},
      mateBefore: {{if .MateBefore}}{{.MateBefore}}{{else}}null{{end}},
      mateAfter: {{if .MateAfter}}{{.MateAfter}}{{else}}null{{end}},
      classification: "{{.Classification}}"
    }
    {{- end}}
  ];

  const orientation = "{{.game.PlayedAs}}" === "black" ? "black" : "white";
  const playedAs = "{{.game.PlayedAs}}";
  const opponent = "{{.game.Opponent}}";
  const profileUsername = "{{.profile.Username}}";
  const whitePlayer = playedAs === "white" ? profileUsername : opponent;
  const blackPlayer = playedAs === "black" ? profileUsername : opponent;
  const whiteRating = playedAs === "white" ? {{.game.PlayerRating}} : {{.game.OpponentRating}};
  const blackRating = playedAs === "black" ? {{.game.PlayerRating}} : {{.game.OpponentRating}};
  
  const boardEl = document.getElementById("board");
  const evalFill = document.getElementById("eval-fill");
  const evalLabel = document.getElementById("eval-label");
  const moveStatus = document.getElementById("move-status");
  const bestMoveNote = document.getElementById("best-move-note");
  const moveListEl = document.getElementById("move-list");
  const moveProgress = document.getElementById("move-progress");
  const autoPlayBtn = document.getElementById("auto-play-btn");
  const playIcon = document.getElementById("play-icon");
  const playSpeed = document.getElementById("play-speed");
  
  let currentIndex = 0;
  let cg;
  let autoPlayInterval = null;
  let isPlaying = false;

  function clampEval(val) {
    if (val > 10) return 10;
    if (val < -10) return -10;
    return val;
  }

  function updateEvalBar(valPawns, mate) {
    if (mate !== null && mate !== undefined) {
      evalFill.style.height = "100%";
      const mateDisplay = Math.abs(mate);
      const isWhiteMate = mate > 0;
      evalLabel.textContent = (isWhiteMate ? "M" : "-M") + mateDisplay;
      evalLabel.classList.toggle("white-advantage", isWhiteMate);
      evalLabel.classList.toggle("black-advantage", !isWhiteMate);
      return;
    }
    const clamped = clampEval(valPawns);
    const percent = ((clamped + 10) / 20) * 100;
    evalFill.style.height = percent + "%";
    evalLabel.textContent = (valPawns >= 0 ? "+" : "") + valPawns.toFixed(1);
    if (valPawns >= 0) {
      evalLabel.classList.remove("black-advantage");
      evalLabel.classList.add("white-advantage");
    } else {
      evalLabel.classList.remove("white-advantage");
      evalLabel.classList.add("black-advantage");
    }
  }

  function formatEvalDelta(evalDiff) {
    const pawns = evalDiff / 100;
    if (Math.abs(pawns) < 0.1) return null;
    return {
      value: pawns,
      isPositive: pawns > 0
    };
  }

  function classForTag(cls) {
    switch ((cls || "").toLowerCase()) {
      case "blunder": return "is-blunder";
      case "mistake": return "is-mistake";
      case "inaccuracy": return "is-inaccuracy";
      case "good":
      case "best": return "is-good";
      default: return "";
    }
  }

  function classForCell(cls) {
    switch ((cls || "").toLowerCase()) {
      case "blunder": return "has-blunder";
      case "mistake": return "has-mistake";
      case "inaccuracy": return "has-inaccuracy";
      case "good":
      case "best": return "has-good";
      default: return "";
    }
  }

  function buildMoveRows() {
    const rows = new Map();
    positions.forEach((p, idx) => {
      // Convert stored move_number to chess move number
      // Stored: 1=white1, 2=black1, 3=white2, 4=black2, etc.
      // Chess: Move 1 = white1+black1, Move 2 = white2+black2, etc.
      const chessMoveNumber = Math.ceil(p.moveNumber / 2);
      
      // Determine if this is a white or black move
      // Odd move_number = white, even move_number = black
      const isWhite = p.moveNumber % 2 === 1;
      const color = isWhite ? "white" : "black";
      
      const key = chessMoveNumber;
      if (!rows.has(key)) rows.set(key, { moveNumber: chessMoveNumber });
      const row = rows.get(key);
      row[color] = { ...p, idx };
    });

    const fragments = [];
    Array.from(rows.values()).forEach(row => {
      const white = row.white;
      const black = row.black;
      const whiteDelta = white ? formatEvalDelta(white.evalDiff) : null;
      const blackDelta = black ? formatEvalDelta(black.evalDiff) : null;
      const whiteIsBest = white && white.movePlayed === white.bestMove;
      const blackIsBest = black && black.movePlayed === black.bestMove;
      
      fragments.push(`
        <div class="move-row">
          <div class="move-num">${row.moveNumber}.</div>
          <div class="move-cell ${white ? "" : "has-background-light"} ${white ? classForCell(white.classification) + (whiteIsBest ? " is-best" : "") : ""}" data-idx="${white ? white.idx : ""}">
            ${white ? `
              <span>${white.movePlayed || "--"}</span>
              <span class="tags">
                <span class="tag ${classForTag(white.classification)} ${whiteIsBest ? 'is-best' : ''}">${(white.classification || "").charAt(0).toUpperCase() + (white.classification || "").slice(1)}</span>
                ${whiteDelta ? `<span class="eval-delta ${whiteDelta.isPositive ? 'positive' : 'negative'}">${whiteDelta.isPositive ? '+' : ''}${whiteDelta.value.toFixed(1)}</span>` : ''}
              </span>
            ` : `<span class="has-text-grey">--</span>`}
          </div>
          <div class="move-cell ${black ? "" : "has-background-light"} ${black ? classForCell(black.classification) + (blackIsBest ? " is-best" : "") : ""}" data-idx="${black ? black.idx : ""}">
            ${black ? `
              <span>${black.movePlayed || "--"}</span>
              <span class="tags">
                <span class="tag ${classForTag(black.classification)} ${blackIsBest ? 'is-best' : ''}">${(black.classification || "").charAt(0).toUpperCase() + (black.classification || "").slice(1)}</span>
                ${blackDelta ? `<span class="eval-delta ${blackDelta.isPositive ? 'positive' : 'negative'}">${blackDelta.isPositive ? '+' : ''}${blackDelta.value.toFixed(1)}</span>` : ''}
              </span>
            ` : `<span class="has-text-grey">--</span>`}
          </div>
        </div>
      `);
    });
    moveListEl.innerHTML = fragments.join("");
    moveListEl.querySelectorAll(".move-cell[data-idx]").forEach(el => {
      el.addEventListener("click", () => {
        const idx = parseInt(el.dataset.idx, 10);
        if (!isNaN(idx)) goToIndex(idx);
      });
    });
  }

  function highlightCurrent() {
    moveListEl.querySelectorAll(".move-cell").forEach(el => el.classList.remove("active"));
    const active = moveListEl.querySelector(`.move-cell[data-idx="${currentIndex}"]`);
    if (active) {
      active.classList.add("active");
      active.scrollIntoView({ block: "center", behavior: "smooth" });
    }
  }

  function drawBestMoveArrow(bestMove) {
    if (!bestMove || bestMove.length < 4) {
      cg.setShapes([]);
      return;
    }
    const from = bestMove.substring(0, 2);
    const to = bestMove.substring(2, 4);
    cg.setShapes([{ orig: from, dest: to, brush: "green" }]);
  }

  function applyMoveToFen(fen, moveUci) {
    if (!moveUci || moveUci.length < 4) return fen;
    try {
      const chess = new Chess(fen);
      const from = moveUci.substring(0, 2);
      const to = moveUci.substring(2, 4);
      const promotion = moveUci.length > 4 ? moveUci.substring(4, 5) : null;
      
      const move = chess.move({
        from: from,
        to: to,
        promotion: promotion || undefined
      });
      
      if (move) {
        return chess.fen();
      }
    } catch (e) {
      console.error("Failed to apply move:", e);
    }
    return fen;
  }

  function highlightLastMove(movePlayed) {
    if (movePlayed && movePlayed.length >= 4) {
      const from = movePlayed.substring(0, 2);
      const to = movePlayed.substring(2, 4);
      cg.set({ lastMove: [from, to] });
    }
  }

  function goToIndex(idx) {
    if (idx < 0 || idx >= positions.length) return;
    currentIndex = idx;
    const pos = positions[idx];
    const evalPawns = pos.evalAfter / 100;
    const mate = pos.mateAfter;
    
    // Apply the move to get the FEN after the move
    const fenAfterMove = applyMoveToFen(pos.fen, pos.movePlayed);
    
    cg.set({ fen: fenAfterMove, orientation });
    updateEvalBar(evalPawns, mate);
    drawBestMoveArrow(pos.bestMove);
    highlightLastMove(pos.movePlayed);
    bestMoveNote.textContent = "Best move: " + (pos.bestMove || "--");
    moveStatus.textContent = "Move " + (idx + 1) + "/" + positions.length;
    highlightCurrent();
    updateNavButtons();
    updateProgress();
  }

  function updateProgress() {
    const percent = ((currentIndex + 1) / positions.length) * 100;
    moveProgress.style.width = percent + "%";
  }

  function toggleAutoPlay() {
    if (isPlaying) {
      stopAutoPlay();
    } else {
      startAutoPlay();
    }
  }

  function startAutoPlay() {
    if (currentIndex >= positions.length - 1) {
      goToIndex(0);
    }
    isPlaying = true;
    playIcon.textContent = "⏸";
    const speed = parseFloat(playSpeed.value);
    const delay = (2 / speed) * 1000;
    
    autoPlayInterval = setInterval(() => {
      if (currentIndex < positions.length - 1) {
        goToIndex(currentIndex + 1);
      } else {
        stopAutoPlay();
      }
    }, delay);
  }

  function stopAutoPlay() {
    isPlaying = false;
    playIcon.textContent = "▶";
    if (autoPlayInterval) {
      clearInterval(autoPlayInterval);
      autoPlayInterval = null;
    }
  }

  function updateNavButtons() {
    const first = document.querySelector('[data-action="first"]');
    const prev = document.querySelector('[data-action="prev"]');
    const next = document.querySelector('[data-action="next"]');
    const last = document.querySelector('[data-action="last"]');
    const atStart = currentIndex <= 0;
    const atEnd = currentIndex >= positions.length - 1;
    first.disabled = atStart;
    prev.disabled = atStart;
    next.disabled = atEnd;
    last.disabled = atEnd;
  }

  function findNextPositionWithDifferentMoveNumber(startIdx, direction) {
    if (startIdx < 0 || startIdx >= positions.length) return startIdx;
    const currentMoveNumber = positions[startIdx].moveNumber;
    let idx = startIdx;
    while (true) {
      idx += direction;
      if (idx < 0 || idx >= positions.length) break;
      if (positions[idx].moveNumber !== currentMoveNumber) {
        return idx;
      }
    }
    return startIdx; // Return original if no different move number found
  }

  function setupNav() {
    const actions = {
      first: () => { stopAutoPlay(); goToIndex(0); },
      prev: () => { 
        stopAutoPlay();
        const nextIdx = findNextPositionWithDifferentMoveNumber(currentIndex, -1);
        goToIndex(nextIdx); 
      },
      next: () => { 
        stopAutoPlay();
        const nextIdx = findNextPositionWithDifferentMoveNumber(currentIndex, 1);
        goToIndex(nextIdx); 
      },
      last: () => { stopAutoPlay(); goToIndex(positions.length - 1); },
    };
    document.querySelectorAll("[data-action]").forEach(btn => {
      btn.addEventListener("click", () => {
        const act = btn.dataset.action;
        if (actions[act]) actions[act]();
      });
    });
    
    autoPlayBtn.addEventListener("click", toggleAutoPlay);
    playSpeed.addEventListener("change", () => {
      if (isPlaying) {
        stopAutoPlay();
        startAutoPlay();
      }
    });
    
    window.addEventListener("keydown", (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      if (e.key === "ArrowLeft") { e.preventDefault(); actions.prev(); }
      if (e.key === "ArrowRight") { e.preventDefault(); actions.next(); }
      if (e.key === "Home") { e.preventDefault(); actions.first(); }
      if (e.key === "End") { e.preventDefault(); actions.last(); }
      if (e.key === " ") { e.preventDefault(); toggleAutoPlay(); }
    });
  }

  function initBoard() {
    const ChessgroundLib = window.Chessground || (typeof Chessground !== "undefined" ? Chessground : null);
    if (!ChessgroundLib) {
      console.error("Chessground not loaded");
      return;
    }
    const startFen = positions.length ? positions[0].fen : "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
    cg = ChessgroundLib(boardEl, {
      fen: startFen,
      orientation,
      viewOnly: true,
      animation: { enabled: true }
    });
  }

  function setupPlayerNames() {
    const nameTop = document.getElementById("name-top");
    const nameBottom = document.getElementById("name-bottom");
    const iconTop = document.getElementById("icon-top");
    const iconBottom = document.getElementById("icon-bottom");
    const ratingTop = document.getElementById("rating-top");
    const ratingBottom = document.getElementById("rating-bottom");
    
    if (orientation === "white") {
      nameBottom.textContent = whitePlayer;
      nameTop.textContent = blackPlayer;
      iconBottom.classList.add("white");
      iconTop.classList.add("black");
      ratingBottom.textContent = whiteRating;
      ratingTop.textContent = blackRating;
    } else {
      nameBottom.textContent = blackPlayer;
      nameTop.textContent = whitePlayer;
      iconBottom.classList.add("black");
      iconTop.classList.add("white");
      ratingBottom.textContent = blackRating;
      ratingTop.textContent = whiteRating;
    }
  }

  function startAnalysis() {
    buildMoveRows();
    initBoard();
    setupNav();
    setupPlayerNames();
    goToIndex(0);
  }

  if (window.addEventListener) {
    window.addEventListener('load', startAnalysis);
  } else if (window.attachEvent) {
    window.attachEvent('onload', startAnalysis);
  } else {
    setTimeout(startAnalysis, 500);
  }
})();
</script>
{{end}}

{{template "foot" .}}
{{end}}
